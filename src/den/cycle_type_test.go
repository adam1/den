// Copyright 2018 Adam Marks

package den

import (
	"math/big"
	"math/rand"
	"testing"
)

func TestEqual(t *testing.T) {
	v := make([]int, 100)
	for i := range v {
		v[i] = rand.Intn(100)
	}
	a := NewCycleType(v)
	b := NewCycleType(v)
	if !a.Equal(b) {
		t.Errorf("expected a to equal b")
	}
	if !b.Equal(a) {
		t.Errorf("expected b to equal a")
	}
}

func TestCopy(t *testing.T) {
	a := RandomCycleType(100)
	b := a.Copy()
	if !a.Equal(b) {
		t.Errorf("expected a to equal b")
	}
}

func TestRandomCycleTypeRespectsDegree(t *testing.T) {
	for i := 0; i < 1000; i++ {
		d := rand.Intn(1000)
		a := RandomCycleType(d)
		if a.Degree() != d {
			t.Errorf("t=%s expected degree=%d got=%d", a.StringWithTilde(), d, a.Degree())
		}
	}
}

func TestOrder(t *testing.T) {
	tcase := func(lambda CycleType, expected int) {
		d := lambda.Order()
		if d != expected {
			t.Errorf("expected=%v got=%v", expected, d)
		}
	}
	tcase(*&CycleType{0,1,0,0,1,1}, 30)
	tcase(*&CycleType{1,1,0,0,1,1}, 30)
	tcase(*&CycleType{0,2,0,0,1,1}, 30)
	tcase(*&CycleType{0,2,0,0,1,1,2}, 210)
}

func TestPower(t *testing.T) {
	tcase := func(x *CycleType, k int, expected *CycleType ) {
		u := x.PowerOld(k)
		if !u.Equal(expected) {
			t.Errorf("x=%v k=%d expected=%v got=%v", x, k, expected, u)
		}
	}
	// order cases from above, all equal 1
	tcase(&CycleType{0,1,0,0,1,1}, 30, &CycleType{13,0,0,0,0,0})
	tcase(&CycleType{1,1,0,0,1,1}, 30, &CycleType{14,0,0,0,0,0})
	tcase(&CycleType{0,2,0,0,1,1}, 30, &CycleType{15,0,0,0,0,0})
	tcase(&CycleType{0,2,0,0,1,1,2}, 210, &CycleType{29,0,0,0,0,0,0})
	// xxx more cases here
}

func TestDegree(t *testing.T) {
	tcase := func(ct CycleType, expected int) {
		d := ct.Degree()
		if d != expected {
			t.Errorf("expected=%v got=%v", expected, d)
		}
	}
	tcase(*&CycleType{0,1,0,0,1,1,0,0,0,0,0,0,0}, 13)
	tcase(*&CycleType{1,1,0,0,1,1,0,0,0,0,0,0,0,0}, 14)
	tcase(*&CycleType{0,2,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 29)
}

func TestCycleTypeToPartition(t *testing.T) {
	// verify CycleType -> Partition -> CycleType round-trip 
	for i := 0; i < 200000; i++ {
		d := rand.Intn(400)
		a := RandomCycleType(d)
		var p Partition
		buf := make([]int, d)
		a.Partition(&p, buf)
		b := make(CycleType, d)
		p.CycleType(b)
		if !a.Equal(&b) {
			t.Errorf("expected=%v got=%v", a, b)
		}
	}
}

func TestCycleTypeToPartitionOrder(t *testing.T) {
	// verify Partition -> CycleType -> Partition to verify that
	// order of parts in partitions generated by ruleAsc are
	// preserved.
	for d := 1; d < 50; d++ {
		buf := make([]int, d)
		for _, p := range AllPartitions(d) {
			ct := make(CycleType, d)
			p.CycleType(ct)
			var q Partition
			ct.Partition(&q, buf)
			if !intSlicesEqual(p, q) {
				t.Errorf("expected=%v got=%v", p, q)
			}
		}
	}
}

func TestPreExtensions(t *testing.T) {
	v := make([]int, 10)
	for i := range v {
		v[i] = rand.Intn(100)
	}
	a := NewCycleType(v)
	n := a.DegreeOld()
	for _, u := range a.PreExtensions() {
		expected := n - 1
		if u.DegreeOld() != expected {
			t.Errorf("expected=%d got=%d", expected, u.DegreeOld())
		}
	}
}

func TestCardinalityOfConjugacyClass(t *testing.T) {
	maxDegree := 33
	for d := 1; d <= maxDegree; d++ {
		sum := big.NewInt(0)
		var P []Partition = AllPartitions(d)
		var ct CycleType = make([]int, d)
		for _, p := range P {
			p.CycleType(ct)
			sum.Add(sum, ct.CardinalityOfConjugacyClass())
		}
		factorial := Factorial(d)
		if factorial.Cmp(sum) != 0 {
			t.Errorf("d=%d conjugacy class sum does not equal factorial! expected=%v got=%v", d, factorial, sum)
		}
	}
}

func TestMarkMethodEquivalentToTotientMethod(t *testing.T) {
	maxDegree := 25
	for d := 1; d <= maxDegree; d++ {
		var P []Partition = AllPartitions(d)
		var ct CycleType = make([]int, d)
		for _, p := range P {
			p.CycleType(ct)
			markMethodHeight := big.NewInt(0)
			totientMethodHeight := big.NewInt(0)
			ct.markMethodHeight(markMethodHeight)
			ct.totientMethodHeight(totientMethodHeight)
			if markMethodHeight.Cmp(totientMethodHeight) != 0 {
				t.Errorf("d=%v t=%v got different values for height! mark=%v totient=%v", d, &ct, markMethodHeight, totientMethodHeight)
			}
		}
	}
}
